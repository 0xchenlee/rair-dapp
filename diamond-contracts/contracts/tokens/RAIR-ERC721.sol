// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.11;
/*
import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';
import '@openzeppelin/contracts/access/AccessControlEnumerable.sol';
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "../diamondStandard/interfaces/IDiamondLoupe.sol";
import "./IERC2981.sol";
import "./IRAIR-ERC721.sol";

//import "hardhat/console.sol";

/// @title  Extended ERC721Enumerable contract for the RAIR system
/// @notice Uses ERC2981 and ERC165 for standard royalty info
/// @notice Uses AccessControl for the minting mechanisms
/// @author Juan M. Sanchez M.
/// @dev    Ideally generated by a RAIR Token Factory
contract RAIR_ERC721 is IERC2981, ERC165, IRAIR_ERC721, ERC721Enumerable, AccessControlEnumerable {
	using Strings for uint;

	struct lockedRange {
		uint startingToken;
		uint endingToken;
		uint lockCountdown;
		uint productIndex;
	}

	mapping(uint => uint[]) public tokensByProduct;
	mapping(uint => uint) public tokenToProduct;
	mapping(uint => uint) private tokenToLock;
	
	//URIs
	string internal baseURI;
	mapping(uint => string) internal uniqueTokenURI;
	mapping(uint => string) internal productURI;
	string internal contractMetadataURI;

	lockedRange[] private _lockedRange;

	//Roles
	bytes32 public constant CREATOR = keccak256("CREATOR");
	bytes32 public constant MINTER = keccak256("MINTER");
	bytes32 public constant TRADER = keccak256("TRADER");

	address public factoryAddress;
	uint16 private _royaltyFee;

	/// @notice	Token's constructor
	/// @dev	RAIR is still the ERC721's symbol
	/// @param	_creatorAddress	Address of the media's creator
	/// @param	_creatorRoyalty	Fee given to the creator on every sale
	constructor(
		string memory _contractName,
		address _creatorAddress,
		uint16 _creatorRoyalty
	) ERC721(_contractName, "RAIR") {
		factoryAddress = msg.sender;
		_royaltyFee = _creatorRoyalty;
		_setRoleAdmin(MINTER, CREATOR);
		_setRoleAdmin(TRADER, CREATOR);
		_setupRole(CREATOR, _creatorAddress);
		_setupRole(MINTER, _creatorAddress);
		_setupRole(TRADER, _creatorAddress);
	}


	/// @notice	Returns information about a product
	/// @param	index	Index of the product
	function getProduct(uint index) external override(IRAIR_ERC721) view returns(uint startingToken, uint endingToken, uint mintableTokensLeft, string memory productName, uint[] memory locks) {
		product memory selectedProduct =  _products[index];
		return (
			selectedProduct.startingToken,
			selectedProduct.endingToken,
			selectedProduct.mintableTokens,
			selectedProduct.name,
			selectedProduct.locks
		);
	}

	/// @notice	Mints a specific token within a product
	/// @dev	Has to be used alongside getNextSequentialIndex to simulate a sequential minting
	/// @dev	Anyone that wants a specific token just has to call this
	/// @param	to					Address of the new token's owner
	/// @param	productId			Product to mint from
	/// @param	indexInProduct	Internal index of the token
	function mint(address to, uint productId, uint indexInProduct) external override(IRAIR_ERC721) onlyRole(MINTER) productExists(productId) {
		product storage currentProduct = _products[productId];
		
		require(indexInProduct <= currentProduct.endingToken - currentProduct.startingToken, "RAIR ERC721: Invalid token index");

		_safeMint(to, currentProduct.startingToken + indexInProduct);

		tokensByProduct[productId].push(currentProduct.startingToken + indexInProduct);

		tokenToProduct[currentProduct.startingToken + indexInProduct] = productId;
		currentProduct.mintableTokens--;

		lockedRange storage lock;
		for (uint i = 0; i < currentProduct.locks.length; i++) {
			if (_lockedRange[currentProduct.locks[i]].startingToken <= currentProduct.startingToken + indexInProduct &&
					_lockedRange[currentProduct.locks[i]].endingToken >= currentProduct.startingToken + indexInProduct) {
				lock = _lockedRange[currentProduct.locks[i]];
				tokenToLock[currentProduct.startingToken + indexInProduct] = currentProduct.locks[i];
				if (lock.lockCountdown > 0) {
					lock.lockCountdown--;
					if (lock.lockCountdown == 0) {
						emit RangeUnlocked(productId, lock.startingToken, lock.endingToken);
					}
				}
				break;
			}
		}
		if (currentProduct.mintableTokens == 0) {
			emit ProductCompleted(productId, currentProduct.name);
		}
	}

	/// @notice Returns the fee for the NFT sale
	/// @param _tokenId - the NFT asset queried for royalty information
	/// @param _salePrice - the sale price of the NFT asset specified by _tokenId
	/// @return receiver - address of who should be sent the royalty payment
	/// @return royaltyAmount - the royalty payment amount for _salePrice sale price
	function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
		external view override(IRAIR_ERC721, IERC2981) returns (address receiver, uint256 royaltyAmount) {
		return (getRoleMember(CREATOR, 0), (_salePrice * _royaltyFee) / 100000);
	}

	function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165, AccessControlEnumerable, ERC721Enumerable, IERC2981) returns (bool) {
		return interfaceId == type(IERC2981).interfaceId
			|| super.supportsInterface(interfaceId);
	}

	
}*/