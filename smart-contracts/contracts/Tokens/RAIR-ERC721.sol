// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.7;

import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';
import '@openzeppelin/contracts/access/AccessControlEnumerable.sol';
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "./IERC2981.sol";
import "./IRAIR-ERC721.sol";

//import "hardhat/console.sol";

/// @title  Extended ERC721Enumerable contract for the RAIR system
/// @notice Uses ERC2981 and ERC165 for standard royalty info
/// @notice Uses AccessControl for the minting mechanisms
/// @author Juan M. Sanchez M.
/// @dev    Ideally generated by a RAIR Token Factory
contract RAIR_ERC721 is IERC2981, ERC165, IRAIR_ERC721, ERC721Enumerable, AccessControlEnumerable {
	struct lockedRange {
		uint startingToken;
		uint endingToken;
		uint lockCountdown;
		uint productIndex;
	}

	struct product {
		uint startingToken;
		uint endingToken;
		uint mintableTokens;
		string name;
		uint[] locks;
	}

	mapping(uint => uint[]) public tokensByProduct;
	mapping(uint => uint) public tokenToCollection;
	mapping(uint => uint) private tokenToLock;
	
	//URIs
	string internal baseURI;
	mapping(uint => string) internal productURI;
	mapping(uint => string) internal tknURI;

	lockedRange[] private _lockedRange;
	product[] private _products;

	//Roles
	bytes32 public constant CREATOR = keccak256("CREATOR");
	bytes32 public constant MINTER = keccak256("MINTER");
	bytes32 public constant TRADER = keccak256("TRADER");

	address private _factory;
	uint16 private _royaltyFee;

	/// @notice	Token's constructor
	/// @dev	RAIR is still the ERC721's symbol
	/// @param	_creatorAddress	Address of the media's creator
	/// @param	_creatorRoyalty	Fee given to the creator on every sale
	constructor(
		string memory _contractName,
		address _creatorAddress,
		uint16 _creatorRoyalty
	) ERC721(_contractName, "RAIR") {
		_factory = msg.sender;
		_royaltyFee = _creatorRoyalty;
		_setRoleAdmin(MINTER, CREATOR);
		_setRoleAdmin(TRADER, CREATOR);
		_setupRole(CREATOR, _creatorAddress);
		_setupRole(MINTER, _creatorAddress);
		_setupRole(TRADER, _creatorAddress);
	}

	modifier productExists(uint productID) {
		require(_products.length > productID, "RAIR ERC721: Collection does not exist");
		_;
	}

	function tokenCountByProduct(uint productIndex) public view returns (uint ) {
		return tokensByProduct[productIndex].length;
	}

	/// @notice	Makes sure a lock can be created
	/// @dev	Used on the createRangeLock call!
	/// @param	productIndex 	Product index
	/// @param	startingToken 	First token to lock
	/// @param	endingToken 	Last token to lock
	function canCreateLock(uint productIndex, uint startingToken, uint endingToken) public view returns (bool canCreate) {
		product storage selectedCollection =  _products[productIndex];
		if (startingToken > selectedCollection.endingToken - selectedCollection.startingToken ||
				endingToken > selectedCollection.endingToken - selectedCollection.startingToken) {
			return false;
		}
		for (uint i = 0; i < selectedCollection.locks.length; i++) {
			if ((_lockedRange[selectedCollection.locks[i]].startingToken <= selectedCollection.startingToken + startingToken &&
					_lockedRange[selectedCollection.locks[i]].endingToken >= selectedCollection.startingToken + startingToken) ||
						(_lockedRange[selectedCollection.locks[i]].startingToken <= selectedCollection.startingToken + endingToken &&
								_lockedRange[selectedCollection.locks[i]].endingToken >= selectedCollection.startingToken + endingToken)) {
				return false;
			}
		}
		return true;
	} 

	/// @notice	Locks transfers for tokens within a specific range
	/// @dev	The minter pays for the locking as well
	/// @param	productIndex Index of the product on the contract
	/// @param	_startingToken Initial token locked
	/// @param	_endingToken Last token locked
	/// @param	_lockedTokens Number of tokens that have to be minted in order to unlock the full range
	function createRangeLock(uint productIndex, uint _startingToken, uint _endingToken, uint _lockedTokens) public onlyRole(CREATOR) productExists(productIndex) {
		product storage selectedCollection =  _products[productIndex];

		require(selectedCollection.startingToken + _endingToken <= selectedCollection.endingToken, 'RAIR ERC721: Invalid ending token');
		require(_endingToken - _startingToken <= selectedCollection.endingToken - selectedCollection.startingToken, 'RAIR ERC721: Invalid token limits');
		require((_endingToken - _startingToken + 1) >= _lockedTokens, 'RAIR ERC721: Invalid number of tokens to lock');

		require(canCreateLock(productIndex, _startingToken, _endingToken), "RAIR ERC721: Cannot create lock");

		lockedRange storage newRange = _lockedRange.push();
		newRange.startingToken = selectedCollection.startingToken + _startingToken;
		newRange.endingToken = selectedCollection.startingToken + _endingToken;
		newRange.lockCountdown = _lockedTokens;
		newRange.productIndex = productIndex;
		selectedCollection.locks.push(_lockedRange.length - 1);
		emit RangeLocked(productIndex, selectedCollection.startingToken + _startingToken, selectedCollection.startingToken + _endingToken, _lockedTokens, selectedCollection.name);
	}

	/// @notice	Creates a product
	/// @dev	Only a CREATOR can call this function
	/// @param	_productName Name of the product
	/// @param	_copies			Amount of tokens inside the product
	function createCollection(string memory _productName, uint _copies) public onlyRole(CREATOR) {
		uint lastToken;
		lastToken = _products.length == 0 ? 0 : _products[_products.length - 1].endingToken + 1;
		
		product storage newCollection = _products.push();

		newCollection.startingToken = lastToken;
		newCollection.endingToken = newCollection.startingToken + _copies - 1;
		newCollection.name = string(_productName);
		newCollection.mintableTokens = _copies;
		
		emit CollectionCreated(_products.length - 1, _productName, _copies);
	}

	/// @notice	Returns the number of products on the contract
	/// @dev	Use with get product to list all of the products
	function getCollectionCount() external view override(IRAIR_ERC721) returns(uint) {
		return _products.length;
	}

	/// @notice	Returns information about a product
	/// @param	index	Index of the product
	function getCollection(uint index) external override(IRAIR_ERC721) view returns(uint startingToken, uint endingToken, uint mintableTokensLeft, string memory productName, uint[] memory locks) {
		product memory selectedCollection =  _products[index];
		return (
			selectedCollection.startingToken,
			selectedCollection.endingToken,
			selectedCollection.mintableTokens,
			selectedCollection.name,
			selectedCollection.locks
		);
	}

	/// @notice	Very inefficient way of verifying if an user owns a token within a product
	/// @dev	But it's a view function so it doesn't matter, just don't use it in a gas transaction
	/// @param	owner			User to search
	/// @param	productIndex	Collection to search
	function hasTokenInCollection(address owner, uint productIndex) public view returns (bool) {
		for (uint i = 0; i < balanceOf(owner); i++) {
			if (tokenToCollection[tokenOfOwnerByIndex(owner, i)] == productIndex) {
				return true;
			}
		}
		return false;
	}

	/// @notice	Returns the token index inside the product
	/// @param	token	Token ID to find
	function tokenToCollectionIndex(uint token) public view returns (uint tokenIndex) {
		return token - _products[tokenToCollection[token]].startingToken;
	} 

	/// @notice	Loops through a range of tokens inside a product and returns the first token without an owner
	/// @dev	Uses a loop, do not call this from a non-view function!
	/// @param	productID	Index of the product to search
	/// @param	startingIndex	Index of the product to search
	/// @param	endingIndex		Index of the product to search
	function getNextSequentialIndex(uint productID, uint startingIndex, uint endingIndex) public view productExists(productID) returns(uint nextIndex) {
		product memory currentCollection = _products[productID];
		for (uint i = currentCollection.startingToken + startingIndex; i <= currentCollection.startingToken + endingIndex; i++) {
			if (!_exists(i)) {
				return i - currentCollection.startingToken;
			}
		}
		require(false, "RAIR ERC721: There are no available tokens in this range.");
	}

	function getLockedRange(uint index) public view returns (uint startingToken, uint endingToken, uint countToUnlock, uint productIndex) {
		lockedRange memory currentLock = _lockedRange[index];
		product memory currentCollection = _products[currentLock.productIndex];
		return (
			currentLock.startingToken - currentCollection.startingToken,
			currentLock.endingToken - currentCollection.startingToken,
			currentLock.lockCountdown,
			currentLock.productIndex
		);
	}

	function isTokenLocked(uint256 _tokenId) public view returns (bool) {
		return _lockedRange[tokenToLock[_tokenId]].productIndex == tokenToCollection[_tokenId] && _lockedRange[tokenToLock[_tokenId]].lockCountdown > 0;
	}

	/// @notice	Mints a specific token within a product
	/// @dev	Has to be used alongside getNextSequentialIndex to simulate a sequential minting
	/// @dev	Anyone that wants a specific token just has to call this
	/// @param	to					Address of the new token's owner
	/// @param	productId			Product to mint from
	/// @param	indexInCollection	Internal index of the token
	function mint(address to, uint productId, uint indexInCollection) external override(IRAIR_ERC721) onlyRole(MINTER) productExists(productId) {
		product storage currentCollection = _products[productId];
		
		require(indexInCollection <= currentCollection.endingToken - currentCollection.startingToken, "RAIR ERC721: Invalid token index");

		_safeMint(to, currentCollection.startingToken + indexInCollection);

		tokensByProduct[productId].push(currentCollection.startingToken + indexInCollection);

		tokenToCollection[currentCollection.startingToken + indexInCollection] = productId;
		currentCollection.mintableTokens--;

		lockedRange storage lock;
		for (uint i = 0; i < currentCollection.locks.length; i++) {
			if (_lockedRange[currentCollection.locks[i]].startingToken <= currentCollection.startingToken + indexInCollection &&
					_lockedRange[currentCollection.locks[i]].endingToken >= currentCollection.startingToken + indexInCollection) {
				lock = _lockedRange[currentCollection.locks[i]];
				tokenToLock[currentCollection.startingToken + indexInCollection] = currentCollection.locks[i];
				if (lock.lockCountdown > 0) {
					lock.lockCountdown--;
					if (lock.lockCountdown == 0) {
						emit RangeUnlocked(productId, lock.startingToken, lock.endingToken);
					}
				}
				break;
			}
		}
		if (currentCollection.mintableTokens == 0) {
			emit CollectionCompleted(productId, currentCollection.name);
		}
	}

	/// @notice Returns the fee for the NFT sale
	/// @param _tokenId - the NFT asset queried for royalty information
	/// @param _salePrice - the sale price of the NFT asset specified by _tokenId
	/// @return receiver - address of who should be sent the royalty payment
	/// @return royaltyAmount - the royalty payment amount for _salePrice sale price
	function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
		external view override(IRAIR_ERC721, IERC2981) returns (address receiver, uint256 royaltyAmount) {
		return (getRoleMember(CREATOR, 0), (_salePrice * _royaltyFee) / 100000);
	}

	function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165, AccessControlEnumerable, ERC721Enumerable, IERC2981) returns (bool) {
		return interfaceId == type(IERC2981).interfaceId
			|| super.supportsInterface(interfaceId);
	}

	/// @notice Queries if an operator can act on behalf of an owner on all of their tokens
	/// @dev Overrides the OpenZeppelin standard by allowing anyone with the TRADER role to transfer tokens
	/// @param owner 		Owner of the tokens.
	/// @param operator 	Operator of the tokens.
	function isApprovedForAll(address owner, address operator) public view virtual override(ERC721, IERC721) returns (bool) {
        return (hasRole(TRADER, operator) || super.isApprovedForAll(owner, operator));
    }

	/// @notice Hook being called before every transfer
	/// @dev	Transfer locking happens here!
	/// @param	_from		Token's original owner
	/// @param	_to			Token's new owner
	/// @param	_tokenId	Token's ID
	function _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal virtual override(ERC721Enumerable) {
		if (_from != address(0) && _to != address(0)) {
			if (_lockedRange[tokenToLock[_tokenId]].productIndex == tokenToCollection[_tokenId]) {
				require(_lockedRange[tokenToLock[_tokenId]].lockCountdown == 0, "RAIR ERC721: Transfers for this range are currently locked");
			}
			_checkRole(TRADER, msg.sender);
		} 
		//require(hasRole(TRADER, _from), 'RAIR ERC721: Transfers cannot be made outside RAIR marketplaces!');
		super._beforeTokenTransfer(_from, _to, _tokenId);
	}
}