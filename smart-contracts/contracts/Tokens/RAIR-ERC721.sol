// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.6;

import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';
import '@openzeppelin/contracts/access/AccessControlEnumerable.sol';
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "./IERC2981.sol";
import "./IRAIR-ERC721.sol";

//import "hardhat/console.sol";

/// @title  Extended ERC721Enumerable contract for the RAIR system
/// @notice Uses ERC2981 and ERC165 for standard royalty info
/// @notice Uses AccessControl for the minting mechanisms
/// @author Juan M. Sanchez M.
/// @dev    Ideally generated by a RAIR Token Factory
contract RAIR_ERC721 is IERC2981, ERC165, IRAIR_ERC721, ERC721Enumerable, AccessControlEnumerable {
	struct lockedRange {
		uint startingToken;
		uint endingToken;
		uint lockCountdown;
		uint collectionIndex;
	}

	struct collection {
		uint startingToken;
		uint endingToken;
		uint mintableTokens;
		string name;
		uint[] locks;
	}

	mapping(uint => uint) private tokenToLock;
	lockedRange[] private _lockedRange;
	collection[] private _collections;

	bytes32 public constant CREATOR = keccak256("CREATOR");
	bytes32 public constant MINTER = keccak256("MINTER");
	bytes32 public constant TRADER = keccak256("TRADER");

	mapping(uint => uint) public tokenToCollection;

	address private _factory;
	uint16 private _royaltyFee;

	/// @notice	Token's constructor
	/// @dev	RAIR is still the ERC721's symbol
	/// @param	_creatorAddress	Address of the media's creator
	/// @param	_creatorRoyalty	Fee given to the creator on every sale
	constructor(
		string memory _contractName,
		address _creatorAddress,
		uint16 _creatorRoyalty
	) ERC721(_contractName, "RAIR") {
		_factory = msg.sender;
		_royaltyFee = _creatorRoyalty;
		_setRoleAdmin(MINTER, CREATOR);
		_setRoleAdmin(TRADER, CREATOR);
		_setupRole(CREATOR, _creatorAddress);
		_setupRole(MINTER, _creatorAddress);
		_setupRole(TRADER, _creatorAddress);
	}

	modifier collectionExists(uint collectionID) {
		require(_collections.length > collectionID, "RAIR ERC721: Collection does not exist");
		_;
	}

	/// @notice	Locks transfers for tokens within a specific range
	/// @dev	The minter pays for the locking as well
	/// @param	collectionIndex Index of the collection on the contract
	/// @param	_startingToken Initial token locked
	/// @param	_endingToken Last token locked
	/// @param	_lockedTokens Number of tokens that have to be minted in order to unlock the full range
	function createRangeLock(uint collectionIndex, uint _startingToken, uint _endingToken, uint _lockedTokens) public onlyRole(CREATOR) collectionExists(collectionIndex) {
		collection storage selectedCollection =  _collections[collectionIndex];

		require(selectedCollection.startingToken + _endingToken <= selectedCollection.endingToken, 'RAIR ERC721: Invalid ending token');
		require(_endingToken - _startingToken <= selectedCollection.endingToken - selectedCollection.startingToken, 'RAIR ERC721: Invalid token limits');
		require((_endingToken - _startingToken + 1) >= _lockedTokens, 'RAIR ERC721: Invalid number of tokens to lock');
		
		lockedRange storage newRange = _lockedRange.push();
		newRange.startingToken = selectedCollection.startingToken + _startingToken;
		newRange.endingToken = selectedCollection.startingToken + _endingToken;
		newRange.lockCountdown = _lockedTokens;
		newRange.collectionIndex = collectionIndex;
		selectedCollection.locks.push(_lockedRange.length - 1);
		emit RangeLocked(collectionIndex, selectedCollection.startingToken + _startingToken, selectedCollection.startingToken + _endingToken, _lockedTokens, selectedCollection.name);
	}

	/// @notice	Creates a collection
	/// @dev	Only a CREATOR can call this function
	/// @param	_collectionName Name of the collection
	/// @param	_copies			Amount of tokens inside the collection
	function createCollection(string memory _collectionName, uint _copies) public onlyRole(CREATOR) {
		uint lastToken;
		lastToken = _collections.length == 0 ? 0 : _collections[_collections.length - 1].endingToken + 1;
		
		collection storage newCollection = _collections.push();

		newCollection.startingToken = lastToken;
		newCollection.endingToken = newCollection.startingToken + _copies - 1;
		newCollection.name = string(_collectionName);
		newCollection.mintableTokens = _copies;
		
		emit CollectionCreated(_collections.length - 1, _collectionName, _copies);
	}

	/// @notice	Returns the number of collections on the contract
	/// @dev	Use with get collection to list all of the collections
	function getCollectionCount() external view override(IRAIR_ERC721) returns(uint) {
		return _collections.length;
	}

	/// @notice	Returns information about a collection
	/// @param	index	Index of the collection
	function getCollection(uint index) external override(IRAIR_ERC721) view returns(uint startingToken, uint endingToken, uint mintableTokensLeft, string memory collectionName, uint[] memory locks) {
		collection memory selectedCollection =  _collections[index];
		return (
			selectedCollection.startingToken,
			selectedCollection.endingToken,
			selectedCollection.mintableTokens,
			selectedCollection.name,
			selectedCollection.locks
		);
	}

	/// @notice	Very inefficient way of verifying if an user owns a token within a collection
	/// @param	owner			User to search
	/// @param	collectionIndex	Collection to search
	function hasTokenInCollection(address owner, uint collectionIndex) public view returns (bool) {
		for (uint i = 0; i < balanceOf(owner); i++) {
			if (tokenToCollection[tokenOfOwnerByIndex(owner, i)] == collectionIndex) {
				return true;
			}
		}
		return false;
	}

	/// @notice	Returns the token index inside the collection
	/// @param	token	Token ID to find
	function tokenToCollectionIndex(uint token) public view returns (uint tokenIndex) {
		return token - _collections[tokenToCollection[token]].startingToken;
	} 

	/// @notice	Loops through a range of tokens inside a collection and returns the first token without an owner
	/// @dev	Uses a loop, do not call this from a non-view function!
	/// @param	collectionID	Index of the collection to search
	/// @param	startingIndex	Index of the collection to search
	/// @param	endingIndex		Index of the collection to search
	function getNextSequentialIndex(uint collectionID, uint startingIndex, uint endingIndex) public view collectionExists(collectionID) returns(uint nextIndex) {
		collection memory currentCollection = _collections[collectionID];
		if ((currentCollection.endingToken + 1) - currentCollection.startingToken == currentCollection.mintableTokens) {
			return 0;
		}
		for (uint i = currentCollection.startingToken + startingIndex; i <= currentCollection.startingToken + endingIndex; i++) {
			if (!_exists(i)) {
				return i - currentCollection.startingToken;
			}
		}
		require(false, "RAIR ERC721: There are no available tokens in this range.");
	}

	function getLockedRange(uint index) public view returns (uint startingToken, uint endingToken, uint countToUnlock, uint collectionIndex) {
		lockedRange memory currentLock = _lockedRange[index];
		return (
			currentLock.startingToken,
			currentLock.endingToken,
			currentLock.lockCountdown,
			currentLock.collectionIndex
		);
	}

	function isTokenLocked(uint256 _tokenId) public view returns (bool) {
		return _lockedRange[tokenToLock[_tokenId]].collectionIndex == tokenToCollection[_tokenId] && _lockedRange[tokenToLock[_tokenId]].lockCountdown == 0;
	}

	/// @notice	Mints a specific token within a collection
	/// @dev	Has to be used alongside getNextSequentialIndex to simulate a sequential minting
	/// @dev	Anyone that wants a specific token just has to call this
	/// @param	to					Address of the new token's owner
	/// @param	collectionID		Collection to mint from
	/// @param	indexInCollection	Internal index of the token
	function mint(address to, uint collectionID, uint indexInCollection) external override(IRAIR_ERC721) onlyRole(MINTER) collectionExists(collectionID) {
		collection storage currentCollection = _collections[collectionID];
		
		require(indexInCollection <= currentCollection.endingToken - currentCollection.startingToken, "RAIR ERC721: Invalid token index");

		_safeMint(to, currentCollection.startingToken + indexInCollection);

		tokenToCollection[currentCollection.startingToken + indexInCollection] = collectionID;
		currentCollection.mintableTokens--;

		lockedRange storage lock;
		for (uint i = 0; i < currentCollection.locks.length; i++) {
			if (_lockedRange[currentCollection.locks[i]].startingToken <= currentCollection.startingToken + indexInCollection &&
					_lockedRange[currentCollection.locks[i]].endingToken >= currentCollection.startingToken + indexInCollection) {
				lock = _lockedRange[currentCollection.locks[i]];
				tokenToLock[currentCollection.startingToken + indexInCollection] = currentCollection.locks[i];
				if (lock.lockCountdown > 0) {
					lock.lockCountdown--;
					if (lock.lockCountdown == 0) {
						emit RangeUnlocked(collectionID, lock.startingToken, lock.endingToken);
					}
				}
				break;
			}
		}
		if (currentCollection.mintableTokens == 0) {
			emit CollectionCompleted(collectionID, currentCollection.name);
		}
	}

	/// @notice Returns the fee for the NFT sale
	/// @param _tokenId - the NFT asset queried for royalty information
	/// @param _value - the sale price of the NFT asset specified by _tokenId
	/// @param _data - information used by extensions of this ERC.
	///                Must not to be used by implementers of EIP-2981 
	///                alone.
	/// @return _receiver - address of who should be sent the royalty payment
	/// @return _royaltyAmount - the royalty payment amount for _value sale price
	/// @return _royaltyPaymentData - information used by extensions of this ERC.
	///                               Must not to be used by implementers of
	///                               EIP-2981 alone.
	function royaltyInfo(uint256 _tokenId, uint256 _value, bytes calldata _data)
		external view override(IRAIR_ERC721, IERC2981) returns (address _receiver, uint256 _royaltyAmount, bytes memory _royaltyPaymentData) {
		return (getRoleMember(CREATOR, 0), (_value * _royaltyFee) / 100000, abi.encodePacked(_tokenId));
	}

	function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165, AccessControlEnumerable, ERC721Enumerable, IERC2981) returns (bool) {
		return interfaceId == type(IERC2981).interfaceId
			|| super.supportsInterface(interfaceId);
	}

	/// @notice Hook being called before every transfer
	/// @dev	Transfer locking happens here!
	/// @param	_from		Token's original owner
	/// @param	_to			Token's new owner
	/// @param	_tokenId	Token's ID
	function _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal virtual override(ERC721Enumerable) {

		if (_from != address(0) && _to != address(0)) {
			if (_lockedRange[tokenToLock[_tokenId]].collectionIndex == tokenToCollection[_tokenId]) {
				require(_lockedRange[tokenToLock[_tokenId]].lockCountdown == 0, "RAIR ERC721: Transfers for this range are currently locked");
			}
			_checkRole(TRADER, msg.sender);
		} 
		//require(hasRole(TRADER, _from), 'RAIR ERC721: Transfers cannot be made outside RAIR marketplaces!');
		super._beforeTokenTransfer(_from, _to, _tokenId);
	}
}