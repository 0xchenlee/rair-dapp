// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4; 

import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/AccessControl.sol';
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./IERC2981.sol";
import "hardhat/console.sol";

/// @title  Extended ERC721Enumerable contract for the RAIR system
/// @notice Uses ERC2981 and ERC165 for standard royalty info
/// @notice Uses AccessControl for the minting mechanisms
/// @author Juan M. Sanchez M.
/// @dev    Ideally generated by a RAIR Token Factory
contract RAIR_ERC721 is IERC2981, ERC165, ERC721Enumerable, AccessControl {
	bytes4 private constant _INTERFACE_ID_ERC2981 = 0xc155531d;
	
	bytes32 public constant CREATOR = keccak256("CREATOR");
	bytes32 public constant MINTER = keccak256("MINTER");

	address private _factory;
	address public creatorAddress;
	uint public supplyLimit;
	// Should the royalty of each creator be public?
	uint16 _royaltyFee;

	/// @notice	Token's constructor
	/// @dev	RAIR is still the ERC721's symbol
	/// @param	_creatorAddress	Address of the media's creator
	/// @param	_creatorRoyalty	Fee given to the creator on every sale
	constructor(
		address _creatorAddress,
		uint _supplyLimit,
		uint16 _creatorRoyalty
	) ERC721("Collectable RAIR Token", "RAIR") {
		_factory = msg.sender;
		_royaltyFee = _creatorRoyalty;
		supplyLimit = _supplyLimit;
		creatorAddress = _creatorAddress;
		_setRoleAdmin(MINTER, CREATOR);
		_setupRole(CREATOR, _creatorAddress);
		_setupRole(MINTER, _creatorAddress);
	}

	/// @notice	Adds an address to the list of allowed minters
	/// @param	_minterAddress	Address of the new Minter
	function addMinter(address _minterAddress) public onlyRole(CREATOR) {
		grantRole(MINTER, _minterAddress);
	}

	/// @notice	Removes an address from the list of allowed minters
	/// @param	_minterAddress	Address of the Minter
	function removeMinter(address _minterAddress) public onlyRole(CREATOR) {
		revokeRole(MINTER, _minterAddress);
	}

	/// @notice	Mints new Tokens for the contract
	/// @param	to		Address of the new Owner
	/// @param	tokenId	ID of the minted Token
	function mint(address to, uint tokenId) external onlyRole(MINTER) {
		require(totalSupply() < supplyLimit, "RAIR ERC721: Cannot mint more tokens");
		_safeMint(to, tokenId);
	}

	function setSupplyLimit(uint _newLimit) public onlyRole(CREATOR) {
		require(_newLimit > totalSupply(), "RAIR ERC721: New limit must be greater than current supply");
		supplyLimit = _newLimit;
	}

	/// @notice Returns the fee for the NFT sale
    /// @param _tokenId - the NFT asset queried for royalty information
    /// @param _value - the sale price of the NFT asset specified by _tokenId
    /// @param _data - information used by extensions of this ERC.
    ///                Must not to be used by implementers of EIP-2981 
    ///                alone.
    /// @return _receiver - address of who should be sent the royalty payment
    /// @return _royaltyAmount - the royalty payment amount for _value sale price
    /// @return _royaltyPaymentData - information used by extensions of this ERC.
    ///                               Must not to be used by implementers of
    ///                               EIP-2981 alone.
	function royaltyInfo(uint256 _tokenId, uint256 _value,	bytes calldata _data)
		external view override(IERC2981) returns (address _receiver, uint256 _royaltyAmount, bytes memory _royaltyPaymentData) {
		require(ownerOf(_tokenId) != address(0), 'Asking for fee on an invalid Token ID!');
		return (creatorAddress, (_value / 100000) * _royaltyFee, abi.encodePacked(_value));
	}

	function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, AccessControl, ERC721Enumerable, IERC2981) returns (bool) {
        return interfaceId == type(IERC2981).interfaceId
            || super.supportsInterface(interfaceId);
    }

    function _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal virtual override(ERC721Enumerable) {
    	super._beforeTokenTransfer(_from, _to, _tokenId);
    } 
}